import{A as e}from"./UIcon.31ae8a4a.js";import{g as t}from"./skills.42ec9d0e.js";import{C as a}from"./types.bf33272f.js";const l=[{slug:"apple-swe-intern",company:"Apple",description:`Walking into Apple, I was handed a challenging problem: 80+ staff were drowning in Excel spreadsheets and Wrike tickets to manage 1200+ business cases. The manual hand-offs were painful, and people spent hours just trying to figure out who owned what.

I decided to rebuild the entire workflow from scratch. The big question was: how do you migrate people off a system they've used for years? I chose Next.js for the frontend because the team needed something familiar yet modern, paired it with Express and PostgreSQL for a robust backend that could handle complex queries.

The authentication piece was fun to design—I implemented JWT with a modular RBAC system that could handle 6 different business roles, each with their own permission levels. Instead of hard-coding permissions everywhere, I built it to be configurable, so adding new roles wouldn't require code changes.

One of my favorite parts was building an n8n AI workflow that automatically summarizes business cases. Managers were spending hours reading through hundreds of cases—now they get intelligent summaries that cut their review time by 40%. I also added OAuth for seamless SSO, SMTP notifications (optimized to p95 latency of 8s), optimistic concurrency control to prevent data conflicts, and ACID-compliant audit logging so we could always trace what changed and why.

The result? Intake time dropped 35%, manual hand-offs disappeared, and the team actually enjoyed using the system. Seeing real users benefit from something I built was incredibly rewarding.`,contract:a.Internship,type:"Software Engineering",location:"Beijing, China",period:{from:new Date(2025,5,30),to:new Date(2025,8,7)},skills:t("nextjs","nodejs","expressjs","postgresql","ts","jwt","oauth"),name:"Software Engineering Intern",color:"blue",links:[],logo:e.Apple,shortDescription:"My first enterprise experience! Learned to build production-level applications and work with real users"},{slug:"cornell-dti",company:"Cornell Digital Tech & Innovation",description:`Joining an 80-member agile team was a completely different experience from working solo. Suddenly, I wasn't just writing code—I was reviewing PRs, coordinating with designers and PMs, and shipping MVPs every semester. It taught me that good communication is just as important as good code.

One of my early contributions was writing comprehensive Notion documentation for new members. I remembered how overwhelming it felt to join such a large team, so I created guides that helped newcomers get productive quickly. Seeing people reference my docs and ramp up faster was surprisingly fulfilling.

The technical work was equally exciting. I built LLM prompts to extract deadlines from course syllabi—sounds simple, but getting to 97% accuracy required a lot of prompt engineering and edge case handling. Different professors format syllabi in wildly different ways, so I had to make the system robust.

I also implemented authentication flows using Firebase and Supabase OAuth. The interesting challenge was supporting multiple auth providers while keeping the user experience seamless. Later, I integrated Supabase real-time to solve a tricky problem: when multiple users edit the same data concurrently, how do you prevent stale writes? Real-time updates meant everyone always saw the latest changes, reducing conflicts significantly.

Working in such a large team taught me to write clearer code, communicate technical decisions better, and appreciate the value of good documentation. It's one thing to build features—it's another to build them in a way that your 79 teammates can understand and maintain.`,contract:a.PartTime,type:"Software Development",location:"Ithaca, NY",period:{from:new Date(2024,8,1)},skills:t("ts","reactjs","firebase","supabase","oauth"),name:"Full-Stack Software Development Engineer",color:"red",links:[],logo:e.CornellDTI,shortDescription:"Growing as a team player in a large agile environment while mentoring newcomers and shipping real products"},{slug:"cornell-ta",company:"Cornell Bowers CIS",description:`Being a TA for Machine Learning and Data Structures gave me a new perspective on code: when you have to explain it to 40+ students, you realize how important clarity really is.

Students were working on 2000+ line projects, and debugging their code taught me more than I expected. I saw every creative way to misunderstand a problem, every edge case I never considered, and every assumption that seemed obvious to me but wasn't to someone new. It made me a better debugger and a more empathetic engineer.

The technical challenge was building automated testing and grading systems in Python and OCaml for 10+ assignments. The goal wasn't just to assign grades—it was to give students meaningful feedback quickly. I designed test suites that would catch common mistakes and provide helpful error messages, not just "Test failed." For example, if someone's binary search tree insertion was wrong, the tests would show exactly which case failed and why.

In OCaml, I had to get creative with the type system to make tests that were both comprehensive and understandable. In Python, I focused on making test output readable—students shouldn't have to parse through cryptic stack traces to understand what went wrong.

The best part? When a student would come to office hours confused, and after walking through their code together, they'd have that "aha!" moment. Those moments reminded me why I love programming—it's about solving problems and helping others solve theirs too.`,contract:a.PartTime,type:"Teaching",location:"Ithaca, NY",period:{from:new Date(2024,7,1)},skills:t("python","ocaml"),name:"Teaching Assistant",color:"green",links:[],logo:e.Cornell,shortDescription:"Giving back by helping others succeed—mentoring students taught me as much as I taught them"},{slug:"ezmodel",color:"#00D9FF",description:`EzModel started from a frustration: why is designing databases still so manual? You draw tables, define relationships, write SQL schemas, build CRUD APIs—it's the same pattern every time. I thought, "there has to be a better way," and rallied a team of 4 engineers to build it.

Leading a team was a new challenge. It wasn't just about writing code anymore—it was about making architectural decisions, delegating work, and keeping everyone aligned. I learned that being a good leader means knowing when to step in and when to trust your team.

The technical architecture was exciting to design. I chose Golang for the backend because we needed low latency (<80ms in-region) for real-time collaboration. WebSocket was the obvious choice over polling—why waste bandwidth checking for updates when the server can push them instantly? Watching multiple users edit the same schema in real-time, with changes appearing immediately, felt like magic.

One of my favorite features is the MCP (Model Context Protocol) server. It analyzes your project context—existing tables, relationships, data patterns—and suggests optimizations. Should this be an index? Is this foreign key relationship correct? It's like having an experienced database engineer looking over your shoulder.

I also set up CI/CD with GitHub Actions to automate testing and deployment. Every PR runs unit and integration tests automatically. It slowed us down initially (writing tests takes time!), but it paid off when we could deploy confidently knowing nothing broke.

Building EzModel taught me that the best tools don't just automate tasks—they help you think better. Auto-generating SQL is cool, but providing intelligent suggestions that improve your database design? That's where the real value is.`,shortDescription:"Leading my first engineering team! Learning to balance technical challenges with collaboration and mentorship",links:[{to:"https://github.com/Shengle-Dai/ezmodel",label:"GitHub"}],logo:e.EzModel,name:"EzModel",period:{from:new Date(2024,8,1)},skills:t("golang","websocket","supabase","svelte","ts"),type:"Database Design Tool",screenshots:[{label:"Real-time Schema Editor",src:"https://images.unsplash.com/photo-1558494949-ef010cbdcc31?ixlib=rb-4.0.3&auto=format&fit=crop&w=500&q=60"},{label:"Auto-generated SQL",src:"https://images.unsplash.com/photo-1533488765986-dfa2a9939acd?ixlib=rb-4.0.3&auto=format&fit=crop&w=500&q=60"},{label:"MCP Context Analysis",src:"https://images.unsplash.com/photo-1460925895917-afdab827c52f?ixlib=rb-4.0.3&auto=format&fit=crop&w=500&q=60"}]},{slug:"ithaca-traveller",color:"#FF6B35",description:`IthacaTraveller was my first real project, built during Cornell Engineering's first-year hackathon. I was nervous—100+ students competing, and I'd never built a full backend before. But I love a good challenge.

The app was a travel guide for Ithaca, and I took on the backend. I chose Flask because it's lightweight and lets you move fast, paired with SQLAlchemy and SQLite for the data layer. The key was designing a clean database schema that could handle locations, reviews, ratings, and user data without getting messy.

The RESTful API design was interesting—I had to think about what endpoints made sense. Should reviews be \`/locations/{id}/reviews\` or \`/reviews?location={id}\`? I went with the nested approach because it felt more intuitive: "give me all reviews for this location."

Integrating a real-time weather API was fun. Travelers want to know if it's going to snow (it's Ithaca—it probably is), so having up-to-date weather info was crucial. The challenge was handling API failures gracefully—what if the weather service goes down? I added caching so we'd show slightly stale data rather than error out.

I also learned Docker and deployed on Google Cloud Platform. Containerization was new to me, but once I understood the concept, it made so much sense. Package everything your app needs, and it runs the same everywhere. Deploying to GCP taught me about cloud infrastructure, environment variables, and why you should never hardcode secrets (learned that one the hard way).

Winning the Best Backend Award among 100+ students was surreal. It wasn't just about writing code that worked—it was about writing code that was robust, well-designed, and reliable. That validation gave me confidence that I could build real systems, not just toy projects.`,shortDescription:"My first project, and it got the hackathon win! This award showed me I could build reliable systems and boosted my confidence",links:[{to:"https://github.com/HackGroup1/IthacaTraveller-API",label:"GitHub"}],logo:e.IthacaTraveller,name:"IthacaTraveller",period:{from:new Date(2023,10,1),to:new Date(2023,11,31)},skills:t("python","flask","sqlite","docker"),type:"Travel Guide App",screenshots:[{label:"API Documentation",src:"https://images.unsplash.com/photo-1551288049-bebda4e38f71?ixlib=rb-4.0.3&auto=format&fit=crop&w=500&q=60"},{label:"Database Schema",src:"https://images.unsplash.com/photo-1544383835-bda2bc66a55d?ixlib=rb-4.0.3&auto=format&fit=crop&w=500&q=60"},{label:"Weather API Integration",src:"https://images.unsplash.com/photo-1592210454359-9043f067919b?ixlib=rb-4.0.3&auto=format&fit=crop&w=500&q=60"}]}].sort((n,o)=>o.period.from.getTime()-n.period.from.getTime()),d="Projects & Experience";export{l as i,d as t};
